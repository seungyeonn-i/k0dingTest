: 그래프의 시작점에서 다른 지점까지의 최단 거리

| 이름 | 간선의 가중치 | 시작점 | 도착점 | 시간 복잡도 |
| --- | --- | --- | --- | --- |
| BFS | 모두 1 | 한 정점 | 모든 정점 | O (V+E) |
| ✅ Dijkstra | ≥ 0 | 한 정점 | 모든 정점 | O (E log V) |

→ Dijkstra가 BFS 보다 시간 복잡도가 좋다!

- 탐색(Search)

  : 시작점에서 간선을 0개 이상 사용해 갈 수 있는 정점들은 무엇인가?

    - DFS / **BFS** ( → 가중치가 적용되지 ❌ 때, 다른 정점까지 최소 이동 횟수도 계산 가능 )

---

### Dijkstra Algorithm

- 요약
    - input
        - Graph G<V,E> = 가중치가 0이상인 가중치 그래프
        - 시작 정점이 주어짐
    - Output
        - 시작점에서 모든점까지의 최단 경로의 거리
    - Time Complexity
        - O (E log V)
- 필요한 정보
    - **dist[i]** : 시작점에서 i번 정점까지 가능한 최단 거리
    - 자료구조 D := { (v,d) | 시작점에서 v까지 d만에 갈 수 있음을 확인한다. }
- 순서도

  > 1️⃣ → 2️⃣ 🔁 6️⃣ →  if( D == null )→ clear
  >

  1️⃣ dist 배열 초기화

  if(i == S) dist[i] 이면 0 // 시작점에서 시작점까지 거리는 0

  else dist[i] 이면 무한 // 시작점 제외 최단거리 측정한 적 없음

  2️⃣ 자료구조 D에 D(S,0) 추가 // 시작점에서 시작점까지 거리 0

  3️⃣ D가 비었나 ?

  4️⃣ 자료구조 D에서 가장 작은 d(거리)를 갖는 (v,d)를 뽑는다.

  5️⃣ 위에서 뽑은 (v,d)의 가치 판단

  dist[v] < d → v까지의 최단거리보다 d가 크다면 가치가 없는 정보이므로 폐기 ~~(v,d)~~

  6️⃣ **d + c < dist[w]** // 지금까지 알던 w보다 , d+c가 작다면

  → **dist[w] = d + c** // dist[w] 업데이트

  → **(w , d+c)** // 자료구조 D도 업데이트