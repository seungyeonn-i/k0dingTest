# 동적 프로그래밍(Dynamic Programmaing)

문제의 크기를 변화하면서(Dynamic) 정답을 계산하는데(Programming), 작은 문제의 결과를 이용해 큰 문제의 정답을 빠르게 계산하는 알고리즘

- 동적 프로그래밍 접근 시도
    - 문제가 원하는 정답을 찾기 위해 가장 먼저 **완전 탐색** 접근을 시도해본다.
    - 근데 완전 탐색 과정에서, **탐색 경우가 지나치게 많은 경우**,
    - 모든 경우를 빠르게 탐색하는 방법으로 **Dynamic Programming을 시도**해 볼 수 있다.

      → **규격화** 된 문제 풀이 순서를 외워 훈련해야한다.

- 동적 프로그래밍의 **규격화**된 방법
    1. **풀고싶은 가짜 문제 정의**
        - 문제 크기 N을 변수로 만들어서 표기하는 경우
            - dy[i] = 1~i 번 원소에 대해 조건을 만족하는 경우의 수
            - dy[i][j] = i ~ j 번 원소에 대해 조건을 만족하는 최대값
            - dy[i][j] = 수열[1..i]][1…j]에 대해 무언가를 계산한 값
        - 문제 크기 N과 마지막 상태를 함께 기록해주는 경우
            - dy[i][0] = i-1 번째 계단을 밟지 않고 i 번째 계단에 도착하여 얻는 최대 점수
            - dy[i][1] = i-1 번째 계단을 밟고서 i번째 계단에 도착하여 얻는 최대 점수
            - dy[i][last] = 길이가 i 이며 last로 끝나는 오르막수의 개수
        - 구간 L ~ R에 대한 문제를 해결할 때
        - 2차원 격자 배열에서 문제를 해결할 때
        - 트리 구조에서 문제를 해결 할 때
    2. **가짜 문제를 풀면 진짜 문제를 풀 수 있는가?**

       예시)

       진짜 문제 : 수열 A[1…N] 에서 조건을 만족하는 부분 수열의 개수

       가짜 문제 : dy[i] = 수열 A[1..i] 에서 조건을 만족하는 부분 수열의 개수

       가짜 문제를 푼다면, dy[1],dy[2] .. dy[N]을 모두 계산 했을 테니, dy[N]에 적혀 있는 값이 곧 진짜 문제가 원하는 값이다.

    3. **초기값을 어떻게 되는가?**

       가장 작은 문제 해결하기

       동적 프로그래밍은 **작은 문제인 초기값을 이용해서 큰 문제를 해결해간다.**

    4. **점화식 구하기**

       초기값 계산한 것을 기반으로 점점 큰 문제들을 해결해가며 dy 배열을 가득 계산하는 과정

    5. **진짜 문제 정답 출력하기**

       1 ~ 4 를 성공적으로 끝낸다면 dy 배열을 이용해 진짜 문제 해결하기

- 동적프로그래밍은 규격화된 형태가 있다. 그 형태를 성공만 하면 코딩의 양은 적다.